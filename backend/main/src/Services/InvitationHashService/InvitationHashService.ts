import { NishikiDynamoDBClient } from "src/Shared/Adapters/DB/NishikiTableClient";
import { Err, Result } from "result-ts-type";
import { IGroupRepository } from "src/Group/Domain/IGroupRepository";
import { GroupId } from "src/Group/Domain/Entities/Group";
import { UserId } from "src/User";
import Md5 from "crypto-js";
import { DomainObjectError, ServiceError } from "src/Shared/Utils/Errors";

export interface IGenerateAnInvitationHashService {
	generateAnInvitationHash(
		groupId: string,
	): Promise<
		Result<string>,
		DomainObjectError | GroupNotFound | PermissionError
	>;
}

export interface IJoinToGroupUsingAnInvitationHashService {
	joinToGroupUsingAnInvitationHash(invitationHash: string): Promise<string>;
}

export class InvitationHashService
	implements
		IGenerateAnInvitationHashService,
		IJoinToGroupUsingAnInvitationHashService
{
	private nishikiDynamoDBClient: NishikiDynamoDBClient;
	private groupRepository: IGroupRepository;

	constructor(
		nishikiDynamoDBClient: NishikiDynamoDBClient,
		groupRepository: GroupRepository,
	) {
		this.nishikiDynamoDBClient = nishikiDynamoDBClient;
		this.groupRepository = groupRepository;
	}

	/**
	 * This method generate an invitation hash.
	 * Before generating an invitation hash, this method check existence of the invitation hash.
	 * If the invitation hash does exist, this method checks the expiry datetime.
	 * If the expiry datetime is over, this method generate a new invitation hash.
	 * If not over, this method returns the invitation hash with updating the expiry datetime.
	 * The invitation hash link is generated by a string of "groupId + expiry Datetime" using MD5.
	 * https://genesis-tech-tribe.github.io/nishiki-documents/proect-document/specifications/detail/invitation-to-group#invitation-link-specification
	 * @param input
	 */
	async generateAnInvitationHash(input: {
		groupId: string;
		userId: string;
	}): Promise<
		Result<string, DomainObjectError | GroupNotFound | PermissionError>
	> {
		const groupIdOrError = GroupId.create(input.groupId);
		const userIdOrError = UserId.create(input.userId);

		if (!(groupIdOrError.ok && userIdOrError.ok)) {
			return Err(groupIdOrError.err || userIdOrError.err);
		}

		const { groupId, userId } = {
			groupId: groupIdOrError.unwrap(),
			userId: userIdOrError.unwrap(),
		};

		const group = await this.groupRepository.find(groupId);

		if (!group) {
			return Err(GroupNotFound("Group not found"));
		}

		if (!group.canEdit(userId)) {
			return Err(
				PermissionError("You don't have permission to access this group."),
			);
		}

		const invitationHash = await this.nishikiDynamoDBClient.getInvitationLink(
			groupId.id,
		);

		const expiryDatetime = new Date(Date.now());
		const hash = Md5(`${groupId.id}${expiryDatetime}`).toString();

		// invitation link doesn't exist.
		if (!invitationHash) {
			await this.nishikiDynamoDBClient.addInvitationLink(
				groupId.id,
				expiryDatetime,
				hash,
			);
			return Result.ok(hash);
		}

		// invitation link doesn't expire.
		if (invitationHash.linkExpiryTime < expiryDatetime) {
			await this.nishikiDynamoDBClient.addInvitationLink(
				groupId.id,
				expiryDatetime,
				invitationHash.invitationLinkHash,
			);
			return Result.ok(hash);
		}

		// invitation link expires, remove it, and generate a new one.
		await Promise.all([
			this.nishikiDynamoDBClient.addInvitationLink(
				groupId.id,
				expiryDatetime,
				invitationHash.invitationLinkHash,
			),
			this.nishikiDynamoDBClient.deleteInvitationLink(invitationHash),
		]);
		return Result.ok(hash);
	}
}

class GroupNotFound extends ServiceError {}
class PermissionError extends ServiceError {}
